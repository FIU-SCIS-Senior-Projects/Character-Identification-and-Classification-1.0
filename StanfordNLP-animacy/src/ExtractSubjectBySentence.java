import java.io.IOException;
import java.io.PrintWriter;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Scanner;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.DocumentBuilder;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import edu.stanford.nlp.io.IOUtils;

import org.w3c.dom.Node;
import org.w3c.dom.Element;
import java.io.File;

/**
 * 
 * @author Geeticka Chauhan
 *
 */
public class ExtractSubjectBySentence 
{
	static String basePath;
	public ExtractSubjectBySentence(String basePath)
	{
		this.basePath = basePath;
	}
	public void Extract(String args[]) throws IOException, ParserConfigurationException, SAXException
	{
		//data used is that generated by the stanford NLP parser
		/*
		String files[] = {basePath + "/outputs/Depen-Parse/story1.xml",
				basePath + "/outputs/Depen-Parse/story2.xml",
				basePath + "/outputs/Depen-Parse/story3.xml",
				basePath + "/outputs/Depen-Parse/story4.xml",
				basePath + "/outputs/Depen-Parse/story5.xml",
				basePath + "/outputs/Depen-Parse/story6.xml",
				basePath + "/outputs/Depen-Parse/story7.xml",
				basePath + "/outputs/Depen-Parse/story8.xml",
				basePath + "/outputs/Depen-Parse/story9.xml",
				basePath + "/outputs/Depen-Parse/story10.xml",
				basePath + "/outputs/Depen-Parse/story11.xml",
				basePath + "/outputs/Depen-Parse/story12.xml",
				basePath + "/outputs/Depen-Parse/story13.xml",
				basePath + "/outputs/Depen-Parse/story14.xml",
				basePath + "/outputs/Depen-Parse/story15.xml"};
				*/
		// figure out why it doesnt show up beyond File1
	    Map<String, String> hashmap = new LinkedHashMap<String, String>(); // to store the word number as key and word as value
	    // in order to remove duplicates from the text file
	    
		for(int i=1; i<=15; i++)
		{ // for every file
			   
		// set up optional output files
	    PrintWriter out;
		if (args.length > 1) {
		out = new PrintWriter(args[1]);
		} else {
		out = new PrintWriter(System.out);
		  }
		PrintWriter xmlOut = new PrintWriter(new File(basePath + "/outputs/Subjects/story" + i + ".txt"));
		/*
		if (args.length > 2) {
		xmlOut = new PrintWriter(args[2]);
	    }
	    */
		// extract within the dep tags, all the dependent ones along with their IDs
		File inputFile = new File(basePath + "/outputs/Depen-Parse/story" + i + ".xml");
        DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
        Document doc = dBuilder.parse(inputFile);
        doc.getDocumentElement().normalize();
        System.out.println("File: " + i);
        System.out.println("Root element :" + doc.getDocumentElement().getNodeName());
        NodeList sentences = doc.getElementsByTagName("sentences");
        // all the sentence elements inside of the sentences tag
        Element sentencesElement = (Element) sentences.item(0);
        NodeList sentenceList = sentencesElement.getElementsByTagName("sentence");
        
       
        for (int temp = 0; temp < sentenceList.getLength(); temp++)  //temp < nList.getLength()
        { // for every sentence element
    		Node sentenceNode = sentenceList.item(temp);
    		//System.out.println("\nCurrent Element :" + nNode.getNodeName());

    		if (sentenceNode.getNodeType() == Node.ELEMENT_NODE) 
    		{
    			// below is each sentence element
    			Element sentenceElement = (Element) sentenceNode;
    			xmlOut.println("<Sentence id=\"" + sentenceElement.getAttribute("id") + "\">");
    		//	System.out.println("Sentence # " + sentenceElement.getAttribute("id"));
    			
    			NodeList dependencies = sentenceElement.getElementsByTagName("dep"); // find the dependencies within the sentence
    			
    			for(int i1 = 0; i1 < dependencies.getLength(); i1++)
    			{
    				Node dependencyNode = dependencies.item(i1);
    				if(dependencyNode.getNodeType() == Node.ELEMENT_NODE)
    				{
    					Element dependencyElement = (Element) dependencyNode;
    					if(dependencyElement.getAttribute("type").equals("nsubj"))
    					{
    						NodeList dependent = dependencyElement.getElementsByTagName("dependent");
    						String word = dependent.item(0).getTextContent();
    	    				String index = dependent.item(0).getAttributes().getNamedItem("idx").getNodeValue().toString();
    	    				hashmap.put(word + "_" + index, "1");
    	    				//xmlOut.println(word + "_" + index);
    	    				//System.out.println(word + "_" + index);
    					}
    				}
    				
    			}
    			Iterator it = hashmap.entrySet().iterator();
    	        while(it.hasNext())
    	        {
    	        	Map.Entry<String, String> pair = (Map.Entry<String, String>) it.next();
    	        	xmlOut.println(pair.getKey());
    	        	it.remove();
    	        	hashmap.remove(pair.getKey());
    	        }
    		//	System.out.println("Type = " + eElement.getAttribute("type"));
    			/*
    			if(sentenceElement.getAttribute("type").equals("nsubj"))
    			{
    				NodeList dependent = sentenceElement.getElementsByTagName("dependent");
    				String word = dependent.item(0).getTextContent();
    				String index = dependent.item(0).getAttributes().getNamedItem("idx").getNodeValue().toString();
    				//System.out.println("word: " + word); // need to extract dependent tag inside of dep
    				//System.out.println("index ie word number " + index);
    				xmlOut.println(word + "_" + index); 
    				//hashmap.put(word + "_" + index, "1"); // only key matters - must sort by key to eliminate duplicates
    				// does not work if you add index as key and word as value because then, you have dragon_7 and he_7 being
    				// put in the same category
    				// value does not matter - i just added 1 to have something in there
    				
    				// above basically returns as a string, the value of the attribute named idx
    			}
    			*/
    			// https://www.mkyong.com/java/how-to-read-xml-file-in-java-dom-parser/ useful resource to understand parsing an xml file
    		  }
        }
        
        System.out.println("Iterator");
      /*
        Iterator it = hashmap.entrySet().iterator();
        while(it.hasNext())
        {
        	Map.Entry<String, String> pair = (Map.Entry<String, String>) it.next();
        	xmlOut.println(pair.getKey());
        	it.remove();
        	hashmap.remove(pair.getKey());
        }
      */
        System.out.println("----------------------------");
        IOUtils.closeIgnoringExceptions(out);
	    IOUtils.closeIgnoringExceptions(xmlOut);
      }
	}
}
